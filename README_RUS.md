# **Cписки**
Мной были реализованы одни из баззовых алгоритмов **STACK**, **SLL** (sigly linked list), **DLL** (double linked list). 

1. [**STACK**](#Stack)
2. [**SLL**](#SLL)
3. [**DLL**](#DLL)


# **Stack** (стэк)
> **Stack** (англ. stack — стопка) - абстрактрый тип данных, представляющий собой список элементов, подчиняющися правилу **LIFO** (last in - first out, последним пришел - первым вышел). Стэк - не является односвязным списком, зато может быть реализован с его помощью. Отличие в том, что у стэка удаление и добавление элементов происходит только на вершине.</br>
> Пример такой реализации может быть - стопка тарелок, стопка тетрадей и тп. 

</br>
В моей программе он реализован с помощью односвязного списка в классе <b>Stack</b>:

```cpp
class Stack {...};
```

### **Сборка библиотеки STACK**

Сборка через **Makefile**
**Stack** собирается в библиотеку ***libstack.a libstack.so*** в директорию ***libs***.

> Для сборки кода как статической библиотеки в терминале (директория проекта ***src***) введите 
> ```sh
> make static_lib_STACK     # сборка статической библиотеки
> make dynamic_lib_STACK:   # сборка динамической библиотеки
> ```

### **Пример использования:**

1. Прилинкуйте библиотеку, удобными для вас способами.
2. Подключите библиотеку через заголовочный файл:
    ```cpp
    #include "stack.hpp"
    ```
3. Объявите стэк указав тип данных:
    ```cpp
    Stack<int> a;
    ...
    Stack<char> a;
    ...
    Stack<float> a;
    ...
    ```
4. Функционал:
    ```cpp
        Stack<int> a;           // объявление стэка
        a.push(123);            // Добавление элемента 123 в вершину стэка. 
        a.top();                // Возврат элемента из вершины стэка
        a.pop();                // Удаление элемента из вершины стэка
        a.print_all();          // Вывод всех элементов стэка начиная с вершины
        a.clear_all();          // Очистка стэка от всех элементов
        if (a.push(123) == 0);  // Память выделилась
        if (a.push(123) != 0);  // Память не была выделена, елемент не был добавлен

    ```

При удаление класса стэк он автоматически очищает выделенную внутри него память.</br>

# **SLL** (Односвязный список).

> [***Линейный односвящный список***](https://ru.wikipedia.org/wiki/%D0%A1%D0%B2%D1%8F%D0%B7%D0%BD%D1%8B%D0%B9_%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA#:~:text=%D0%9E%D0%B4%D0%BD%D0%BE%D1%81%D0%B2%D1%8F%D0%B7%D0%BD%D1%8B%D0%B9%20%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA%20(%D0%BE%D0%B4%D0%BD%D0%BE%D0%BD%D0%B0%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9%20%D1%81%D0%B2%D1%8F%D0%B7%D0%BD%D1%8B%D0%B9%20%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA),-%D0%A0%D0%B0%D0%B7%D0%BD%D0%BE%D0%B2%D0%B8%D0%B4%D0%BD%D0%BE%D1%81%D1%82%D1%8C%20%D1%81%D0%B2%D1%8F%D0%B7%D0%BD%D0%BE%D0%B3%D0%BE%20%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%B0&text=%D0%9B%D0%B8%D0%BD%D0%B5%D0%B9%D0%BD%D1%8B%D0%B9%20%D0%BE%D0%B4%D0%BD%D0%BE%D0%BD%D0%B0%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9%20%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA%20%E2%80%94%20%D1%8D%D1%82%D0%BE%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0,%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%20%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%B0%20%D1%83%D0%BA%D0%B0%D0%B7%D1%8B%D0%B2%D0%B0%D0%B5%D1%82%20%D0%BD%D0%B0%20NULL.) (*абстрактный тип данных (АТД)*)— это структура данных, состоящая из элементов одного типа, связанных между собой последовательно посредством указателей. Каждый элемент списка имеет указатель на следующий элемент. Последний элемент списка указывает на ***NULL***. Элемент, на который нет указателя, является первым (*вершиной*) элементом списка. Здесь ссылка в каждом узле указывает на следующий узел в списке. В односвязном списке можно передвигаться только в сторону конца списка. Узнать адрес предыдущего элемента, опираясь на содержимое текущего узла, невозможно.

> На базе односвязного cписка можно реализовать очередь (**FIFO**), (**stack**).

В моей программе односвязный список реализован с помощью класса (шаблона класса) **SSL** (*Singly linked list*): `class SLL {...}`

```cpp
    #include "SLL.hpp"      // Подключение библиотеки
    ...
    SLL<float> a;           // Объявление переменной типа SLL, coдержащий данные float
    a.push_back(123.33);    // Добавить в конец списка 123.33
    a.push_forward(7.3);    // Добавить в начало списка 7.3
    a.prind_all();          // Вывод в stdout весь список начиная с вершины
    a.clear_all();          // Очистка всего списка
    a.remove_first();       // Удалить элемент с самого начала списка
    a.remove_last();        // Удалить элемент с вершины (последний) элемент
    a.top_firts();          // Вернуть (не удаляя) элемент в начале списка
    a.top_last();           // Вернуть (не удаляя) элемент с конца (вершины) списка

    // Если память не выделена a.push_back() или a.push_forward() вернет единицу
    if (a.push_back(123) != 0) std::cout << "Error"; //

    // Поиск индекса элемента new_element в списке
    float new_element = 123.33;
    int index = a.fint_index(new_element);
    
    // Поиск элемента по индексу:
    float b = 0;
    int index = 3;
    b = a.find_by_index(index);

```
При удаление объекта класса SLL он автоматически очиститься.</br>

### **Сборка библиотеки SLL**

Сборка через **Makefile**
**SLL** собирается в библиотеку ***libSLL.a libSLL.so*** в директорию ***libs***.
> Для сборки кода как статической библиотеки в терминале (директория проекта ***src***) введите 
> ```sh
> make static_lib_SLL     # сборка статической библиотеки
> make dynamic_lib_SLL:   # сборка динамической библиотеки
> ```


# DLL (Двусвязный список).

> ***Двусвязный список*** - структура состоящая из элементов одного типа, связанных между собой посредством указателей, где указателей. Где элемент имеет указатель как на следующий элемент, так и на предыдущий (Две связи).

На базе двусвязного cписка можно реализовать гибкую очередь (**FIFO**), (**stack**).

В моей программе он представлен в виде класса: `class DLL {...}`.

```cpp
    #include "Dll.hpp"                  // Подключение библиотеки
    ...
    DLL<char> a;                        // Объявление переменной типа DLL, содержащие элементы char
    a.clear_all();                      // Очистка всего списка
    a.print_all();                      // Распечатать весь список с вершины (конца)
    a.print_all_reverse();              // Распечатать весь список с начала
    
    // Добавление элементов в список
    a.push_forward('A');                // Добавить в начало символ А
    a.push_back('Z');                   // Добавить в конец символ Z
    a.insert_before_element('A', 'B');  // Добавить перед A символ B
    a.insert_after_element('Z', 'Y');   // Добавить после Z символ Y
    a.insert_before_index(1, 'a');      // Добавить перед первым элементом символ a
    a.insert_after_index(5, 'y');       // Добавить после 5го элемента символ y

    // Все эти функции вернут цифру отличную от нуля, если память будет не выделена
    if (a.push_back('E') != 0) std::cout << "Memory was not allocated\n";

    // Удаления элементов из списка
    a.remove_by_index(1);                // Удалит первый элемент
    a.remove_element("A");               // Удалит последнее вхождение элемента A
    a.remove_first();                    // Удалит первый элемент(начальный) из списка
    a.remove_last();                     // Удалит последний элемент из списка

    // Все эти функции вернут удаляемый элемент из списка или 0
    std::cout << a.remove_first() << std::endl;

    // Поиск по индексу
    a.find_index('C');                   // Вернет индекс последнего вхождения элемента C
    a.find_by_index(1);                  // Вернет элемент под индексом 1
    a.top_index();                       // Вернет индекс последнего элемента
    a.top_first();                       // Вернет первый элемент
    a.top_last();                        // Вернет последний элемент (на вершине стэка);
```
При удаление объекта класса DLL он автоматически очиститься.</br>

### **Сборка библиотеки DLL**

Сборка через **Makefile**
**DLL** собирается в библиотеку ***libDLL.a libDLL.so*** в директорию ***libs***.
> Для сборки кода как статической библиотеки в терминале (директория проекта ***src***) введите 
> ```sh
> make static_lib_DLL     # сборка статической библиотеки
> make dynamic_lib_DLL:   # сборка динамической библиотеки
> ```
