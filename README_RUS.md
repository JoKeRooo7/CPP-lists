# **Cписки**
Мной были реализованы одни из баззовых алгоритмов **STACK**, **SLL**, 

1. ["**STACK**"](#Stack)
2. ["**SLL**"](#SLL)


# **Stack (стэк)**
> **Stack** (англ. stack — стопка) - абстрактрый тип данных, представляющий собой список элементов, подчиняющися правилу **LIFO** (last in - first out, последним пришел - первым вышел). Стэк - не является односвязным списком, зато может быть реализован с его помощью. Отличие в том, что у стэка удаление и добавление элементов происходит только на вершине.</br>
> Пример такой реализации может быть - стопка тарелок, стопка тетрадей и тп. 

</br>
В моей программе он реализован с помощью односвязного списка в классе <b>Stack</b>:

```cpp
class Stack {...};
```
При удаление класса стэк он автоматически очищает выделенную внутри него память.</br>
**Stack** представлен он в виде библиоеки ***libstack.a libstack.so***.

## **Сборка библиотеки STACK**

Для сборки библиотек я использую **Makefile**

> ### **Cборка статической библиотеки STACK**:
>___
> Для сборки кода как статической библиотеки в ***src*** введите 
> ```sh
> make static_lib_STACK
> ```
> Статическая библиотека будет помещена в директорию ***libs*** с названием ***libstack.a***
> ### **Cборка динамической библиотеки STACK**:
>___
> Для сборки кода как динамической библиотеки в ***src** введите 
> ```sh
> make dynamic_lib_STACK:
> ```
> Динамическая библиотека будет помещена в директорию ***libs*** с названием ***libstack.so***


## **Применение:**

1. Прилинкуйте библиотеку, удобными для вас способами.
2. Подключите библиотеку через заголовочный файл:
    ```cpp
    #include "stack.hpp"
    ```
3. Объявите стэк указав тип данных:
    ```cpp
    Stack<int> a;
    ...
    Stack<char> a;
    ...
    Stack<float> a;
    ...
    ```
4. Функционал:
    ```cpp
        Stack<int> a;           // объявление стэка
        a.push(123);            // Добавление элемента 123 в вершину стэка. 
        a.top();                // Возврат элемента из вершины стэка
        a.pop();                // Удаление элемента из вершины стэка
        a.print_all();          // Вывод всех элементов стэка начиная с вершины
        a.clear_all();          // Очистка стэка от всех элементов
        if (a.push(123) == 0);  // Память выделилась
        if (a.push(123) != 0);  // Память не была выделена, елемент не был добавлен

    ```

# **SLL** (Односвязный список).

> [**Линейный односвящный список**](https://ru.wikipedia.org/wiki/%D0%A1%D0%B2%D1%8F%D0%B7%D0%BD%D1%8B%D0%B9_%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA#:~:text=%D0%9E%D0%B4%D0%BD%D0%BE%D1%81%D0%B2%D1%8F%D0%B7%D0%BD%D1%8B%D0%B9%20%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA%20(%D0%BE%D0%B4%D0%BD%D0%BE%D0%BD%D0%B0%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9%20%D1%81%D0%B2%D1%8F%D0%B7%D0%BD%D1%8B%D0%B9%20%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA),-%D0%A0%D0%B0%D0%B7%D0%BD%D0%BE%D0%B2%D0%B8%D0%B4%D0%BD%D0%BE%D1%81%D1%82%D1%8C%20%D1%81%D0%B2%D1%8F%D0%B7%D0%BD%D0%BE%D0%B3%D0%BE%20%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%B0&text=%D0%9B%D0%B8%D0%BD%D0%B5%D0%B9%D0%BD%D1%8B%D0%B9%20%D0%BE%D0%B4%D0%BD%D0%BE%D0%BD%D0%B0%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9%20%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA%20%E2%80%94%20%D1%8D%D1%82%D0%BE%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0,%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%20%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%B0%20%D1%83%D0%BA%D0%B0%D0%B7%D1%8B%D0%B2%D0%B0%D0%B5%D1%82%20%D0%BD%D0%B0%20NULL.) (*абстрактный тип данных (АТД)*)— это структура данных, состоящая из элементов одного типа, связанных между собой последовательно посредством указателей. Каждый элемент списка имеет указатель на следующий элемент. Последний элемент списка указывает на ***NULL***. Элемент, на который нет указателя, является первым (*вершиной*) элементом списка. Здесь ссылка в каждом узле указывает на следующий узел в списке. В односвязном списке можно передвигаться только в сторону конца списка. Узнать адрес предыдущего элемента, опираясь на содержимое текущего узла, невозможно.

В моей программе односвязный список реализован с помощью класса (шаблона класса) **SSL** (*Singly linked list*):
```cpp
    class SLL {...}
```
Объявление переменной типа **SLL**, coдержащий данные `float`:
```cpp
    SSL<float> a;
```
Добавить в конец списка `123.33`:
```cpp
    a.push_back(123.33);
```
Добавить в начало списка `7.3`:
```cpp
    a.push_forward(7.3);
```

* Если память не выделена `a.push_back()` `a.push_forward()`вернет единицу:
```cpp
    if (a.push_back(123) != 0) std::cout << "Error";
```

Найти индекс элемента `new_element`:
```cpp
    float new_element = 123.33;
    int index = a.fint_index(new_element);
```

Распечатать в стандартный поток вывода все эелементы *SLL* начиная с вершины:
```cpp
    a.prind_all();
```

Очистить все элементы (вызов функции очисти авттматический при удаление класса):
```cpp
    a.clear_all();
```

Найти элемент по индексу:
```cpp
    float b = 0;
    int index = 3;
    b = a.find_by_index(index);
```

Удалить элемент с самого начала списка:
```cpp
    a.remove_first();
```

Удалить элемент с вершины (последний) элемент:
```cpp
    a.remove_last();
```

Вернуть элемент(не удаляя) из начала списка и из конца списка:
```cpp
    a.top_firts();
    a.top_last();
```

## **Сборка библиотеки SLL**

> ### **Cборка статической библиотеки SLL**:
>___
> Для сборки кода как статической библиотеки в ***src*** введите 
> ```sh
> make static_lib_SLL
> ```
> Статическая библиотека будет помещена в директорию ***libs*** с названием ***libSLL.a***
> ### **Cборка динамической библиотеки SLL**:
>___
> Для сборки кода как динамической библиотеки в ***src** введите 
> ```sh
> make dynamic_lib_SLL:
> ```
> Динамическая библиотека будет помещена в директорию ***libs*** с названием ***libSLL.so***


